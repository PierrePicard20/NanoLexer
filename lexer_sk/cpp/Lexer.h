//
// Lexer generated by NanoLexer v0.1
// Â© Pierre Picard 2021
// source : $(LexerName)Lexer.h
// generated from skeleton file Lexer.h
//
#ifndef $(LexerName)LEXER
#define $(LexerName)LEXER
#include <string>

namespace NanoLexer
{
	// Stream template must inherit from basic_istream (most of the time istringstream or ifstream)
    template <typename Stream>
    class $(LexerName)Lexer
    {
    public:
        using Traits = typename Stream::traits_type;

		enum class Lexeme
		{
			unknown_ = -1,
			eof_,
			$(LexemeNames)
		};

        $(LexerName)Lexer(Stream& in)
			:inputStream{ in }
		{
            accepted = Lexeme::unknown_;
			nbRead = 0;
			nbReadAfterAccept = 0;
$(OnCreate)
		}

		inline const std::string& getMatchString() const {return matchString;}
		inline Lexeme getAcceptedLexeme() const {return accepted;}
		inline int getMatchLength() const {return nbRead;}

        Lexeme getNextToken()
        {
$(OnStartNextToken)
            matchString = "";
            accepted = Lexeme::unknown_;
            while (true)
            {
                nbRead = 0;
                nbReadAfterAccept = 0;
                main_context();
                if (accepted != Lexeme::unknown_)
                {
                    while (nbReadAfterAccept)
                    {
                        unget();
                    }
                    if (matchString.size() > nbRead)
                    {
                        while (nbRead)
                        {
                            unget();
                        }
                        return Lexeme::unknown_;
                    }
					onMatch();
                    return accepted;
                }
            }
        }
		
        int get()
        {
            int c;
            if (buf.size())
            {
                c = buf.back();
                buf.pop_back();
            }
            else
            {
                c = inputStream.get();
            }
            if (c != Traits::eof())
            {
                matchString += c;
                nbRead++;
                nbReadAfterAccept++;
            }
            return c;
        }
        
        void unget()
        {
            nbRead--;
            nbReadAfterAccept--;
            buf.push_back(matchString.back());
            matchString.pop_back();
        }
		
		const char* getLexemeName(Lexeme l)
		{
			switch (l)
			{
				case Lexeme::unknown_: return "unknown";
				case Lexeme::eof_: return "eof";
				$(GetLexemeNamesCases)
				default: return "<UNDEFINED>";
			}
		}

		const char* getLexemeExpression(Lexeme l)
		{
			switch (l)
			{
				case Lexeme::unknown_: return "<UNKNOWN>";
				case Lexeme::eof_: return "<EOF>";
				$(GetLexemeExpressionsCases)
				default: return "<UNDEFINED>";
			}
		}
        
$(PublicMembers)

	protected:
$(ProtectedMembers)

    private:
$(PrivateMembers)

$(LexerContextsMethods)
        std::string     buf;
        int             nbReadAfterAccept;
        Stream&         inputStream;
        std::string     matchString;
        Lexeme          accepted;
        int             nbRead;
		
		void onMatch()
		{
			switch (accepted)
			{
$(OnMatch)
			}
		}
        
        void accept(Lexeme l)
        {
            accepted = l;
            nbReadAfterAccept = 0;
        }
    };
}
#endif